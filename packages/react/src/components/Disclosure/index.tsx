import React from 'react';
import classNames from 'classnames';
import debounce from 'lodash.debounce';
import isEqual from 'react-fast-compare';
import { hasTransition, prefix } from '../../utilities';
import { BaseDetails, BaseDetailsProps } from '../BaseDetails';
import { BaseSummary, BaseSummaryProps } from '../BaseSummary';
import { Icon } from '../Icon';

export type DisclosureAnatomy = 'summary' | 'marker' | 'contentsInner' | 'contentsOuter';
export type DisclosureLifecycleState = 'open' | 'closed' | 'opening' | 'closing';
export type DisclosureCallbackName = 'onCloseStart' | 'onCloseCancel' | 'onCloseEnd' | 'onOpenStart' | 'onOpenCancel' | 'onOpenEnd';
export interface DisclosureState {
	lifecycle: DisclosureLifecycleState;
	height?: number;
}

export interface DisclosureProps extends BaseDetailsProps {
	/** The content for the summary element generated by the disclosure component. */
	summary: string;
	/** The base `className` according to BEM conventions. */
	baseName?: string;
	/** The `className` that will be applied to the `<summary>`. */
	summaryClass?: string;
	/** The `className` for the outer contents `<div>`. */
	contentsOuterClass?: string;
	/** The `className` that will be applied to the inner contents `<div>`. */
	contentsInnerClass?: string;
	/** A class that will be applied to the outer contents `<div>` while opening. */
	closingClass?: string;
	/** A class that will be applied to the outer contents `<div>` while closing. */
	openingClass?: string;
	/**
	 * The `className` that will be applied to the summary's icon indicator,
	 * which takes the place of the native `summary::marker` pseudo element.
	 */
	markerClass?: string;
	/** Whether resizing the window should trigger a height calculation update. */
	updateOnResize?: boolean;
	/**
	 * The variant for the disclosure. An undefined variant will cause the
	 * disclosure to look like a standard `<details>`.
	 */
	variant?: 'panel';
	/** Whether to animate the opening/closing of the disclosure. */
	animate?: boolean;
	/** A reference to the inner <details> element. */
	detailsRef?: React.RefObject<HTMLDetailsElement>;
	/**
	 * Lifecycle method that is triggered when the disclosure begins to close.
	 * Returning `false` will prevent the disclosure from beginning to close.
	 */
	onCloseStart?: () => boolean | void | Promise<boolean | void>;
	/**
	 * Lifecycle method that is triggered when the user clicks on the disclosure
	 * as it's closing. Returning `false` will cause the disclosure to continue
	 * closing.
	 */
	onCloseCancel?: () => boolean | void | Promise<boolean | void>;
	/**
	 * Lifecycle method that is triggered when the disclosure has finished closing.
	 * Returning `false` will prevent the disclosure from fully closing.
	 */
	onCloseEnd?: () => boolean | void | Promise<boolean | void>;
	/**
	 * Lifecycle method that is triggered when the disclosure begins to open.
	 * Returning `false` will prevent the disclosure from beginning to open.
	 */
	onOpenStart?: () => boolean | void | Promise<boolean | void>;
	/**
	 * Lifecycle method that is triggered when the user clicks on the disclosure
	 * as it's opening. Returning `false` will cause the disclosure to continue
	 * opening.
	 */
	onOpenCancel?: () => boolean | void | Promise<boolean | void>;
	/**
	 * Lifecycle method that is triggered when the disclosure has finished opening.
	 * Returning `false` will prevent the disclosure from fully opening.
	 */
	onOpenEnd?: () => boolean | void | Promise<boolean | void>;
}

export class Disclosure extends React.PureComponent<DisclosureProps, DisclosureState> {
	/**
	 * The time in milliseconds to delay when recalculating the contents height
	 * due to a window resize. Only applies if `updateOnResize` is `true`.
	*/
	public static RESIZE_DEBOUNCE_DELAY = 150;
	public static bemBase = 'disclosure';
	public static bemElements: Record<DisclosureAnatomy, string> = {
		summary: 'summary',
		marker: 'marker',
		contentsInner: 'contents-inner',
		contentsOuter: 'contents-outer',
	}

	private baseName: string;
	public detailsRef: React.RefObject<HTMLDetailsElement>;
	public contentsHeight = 0;
	public contentsOuter: HTMLDivElement | null = null;

	public static defaultProps = {
		baseName: Disclosure.bemBase,
		animate: true,
		open: false,
		updateOnResize: true,
	}

	constructor(props: DisclosureProps) {
		super(props);
		this.state = {
			lifecycle: props.open ? 'open' : 'closed',
		};
		this.baseName = prefix(Disclosure.defaultProps.baseName);
		this.detailsRef = props.detailsRef || React.createRef<HTMLDetailsElement>();
	}

	componentDidMount(): void {
		const { animate } = this.props;
		if (animate) {
			this.initialize();
		}
	}

	componentDidUpdate(prevProps: DisclosureProps): void {
		const {
			open,
			animate,
			detailsRef,
			children,
			baseName,
		} = this.props;
		if (detailsRef && detailsRef !== prevProps.detailsRef) {
			this.detailsRef = detailsRef;
		}

		if (prevProps.open && !open) {
			this.close();
		} else if (!prevProps.open && open) {
			this.open();
		}

		if (prevProps.animate && !animate) {
			this.reset();
		} else if (!prevProps.animate && animate) {
			this.initialize();
		}

		if (!isEqual(prevProps.children, children)) {
			this.initialize();
		}

		if (baseName) this.baseName = baseName;
	}

	private onWindowresize = debounce(() => {
		const { lifecycle } = this.state;
		this.removeHeight();
		this.contentsHeight = this.findHeight();
		if (lifecycle === 'opening' || lifecycle === 'open') {
			this.setState({ height: this.contentsHeight });
		}
		if (lifecycle === 'closing' || lifecycle === 'closed') {
			this.setState({ height: 0 });
		}
	}, Disclosure.RESIZE_DEBOUNCE_DELAY)

	/**
	 * The `<summary>` click handler.
	 *
	 * As soon as a `<details>` element no longer has the `open` attribute,
	 * its inner contents disappear. To prevent this, we transition the height
	 * of the contents via its outer container, delaying the removal of the
	 * `open` attribute until the `transitionend` event triggers.
	 */
	private onSummaryClick = (e: React.MouseEvent<HTMLElement>): void => {
		e.preventDefault();
		const { lifecycle } = this.state;
		switch (lifecycle) {
			case 'opening':
				this.openCancel();
				break;
			case 'open':
				this.closeStart();
				break;
			case 'closing':
				this.closeCancel();
				break;
			case 'closed':
				this.openStart();
				break;
			default:
		}
	}

	// The transition begins with the summary click. On end, update the state if it's closed.
	private onTransitionend = (): void => {
		const { lifecycle } = this.state;
		if (lifecycle === 'opening') {
			this.openEnd();
		} else if (lifecycle === 'closing') {
			this.closeEnd();
		}
	}

	private get isOpen(): boolean {
		const { lifecycle } = this.state;
		return lifecycle !== 'closed';
	}

	private get shouldAnimate(): boolean {
		const { animate } = this.props;
		return Boolean(animate) && hasTransition(this.contentsOuter);
	}

	private get Summary(): JSX.Element {
		const {
			summary,
			variant,
			summaryClass = `${this.baseName}__${Disclosure.bemElements.summary}`,
			markerClass = `${this.baseName}__${Disclosure.bemElements.marker}`,
		} = this.props;
		if (React.isValidElement<BaseSummaryProps>(summary)) {
			return summary;
		}
		const markerType = (variant === 'panel') ? 'chevron-down' : 'caret-right';
		const markerElement = <Icon variant={markerType} className={markerClass} />;
		const markerPosition = variant === 'panel' ? 'right' : 'left';
		return (
			<BaseSummary
				className={summaryClass}
				marker={markerElement}
				onClick={this.onSummaryClick}
				markerPosition={markerPosition}
			>
				{summary}
			</BaseSummary>
		);
	}

	private async closeStart(): Promise<void> {
		if (await this.callback('onCloseStart')) {
			this.setState({
				lifecycle: (this.shouldAnimate) ? 'closing' : 'closed',
				height: 0,
			});
		}
	}

	private async closeCancel(): Promise<void> {
		if (await this.callback('onCloseCancel')) {
			this.setState({ lifecycle: 'opening', height: this.contentsHeight });
		}
	}

	private async closeEnd(): Promise<void> {
		if (await this.callback('onCloseEnd')) {
			this.setState({ lifecycle: 'closed' });
		}
	}

	private async openStart(): Promise<void> {
		if (await this.callback('onOpenStart')) {
			this.setState({
				lifecycle: (this.shouldAnimate) ? 'opening' : 'open',
				height: this.contentsHeight,
			});
		}
	}

	private async openCancel(): Promise<void> {
		if (await this.callback('onOpenCancel')) {
			this.setState({ lifecycle: 'closing', height: 0 });
		}
	}

	private async openEnd(): Promise<void> {
		if (await this.callback('onOpenEnd')) {
			this.setState({ lifecycle: 'open' });
		}
	}

	private open(): void {
		this.setState({ lifecycle: (this.shouldAnimate) ? 'opening' : 'open' });
	}

	private close(): void {
		this.setState({ lifecycle: (this.shouldAnimate) ? 'closing' : 'closed' });
	}

	private findHeight(): number {
		const { current: detailsRef } = this.detailsRef;
		if (detailsRef && this.contentsOuter) {
			const style = this.contentsOuter.getAttribute('style');
			this.contentsOuter.removeAttribute('style');
			if (!this.isOpen) detailsRef.setAttribute('open', 'open');
			const { clientHeight } = this.contentsOuter;
			if (!this.isOpen) detailsRef.removeAttribute('open');
			if (style) this.contentsOuter.setAttribute('style', style);
			return clientHeight;
		}
		return 0;
	}

	private initialize(): void {
		const { lifecycle } = this.state;
		const { updateOnResize } = this.props;
		this.contentsHeight = this.findHeight();

		if (this.shouldAnimate) {
			this.setState({ height: (lifecycle === 'open') ? this.contentsHeight : 0 });
			if (updateOnResize) {
				window.addEventListener('resize', this.onWindowresize);
			}
		}
	}

	private reset(): void {
		const { updateOnResize } = this.props;
		this.removeHeight();
		if (updateOnResize) {
			window.removeEventListener('resize', this.onWindowresize);
		}
	}

	private removeHeight(): void {
		if (this.contentsOuter) {
			this.setState({ height: undefined });
		}
	}

	private async callback(name: DisclosureCallbackName): Promise<boolean> {
		const { [name]: method } = this.props;
		if (method) {
			const methodReturn = await method();
			if (methodReturn !== undefined) return methodReturn;
		}
		return true;
	}

	render(): JSX.Element {
		const {
			// classes
			className,
			contentsInnerClass = `${this.baseName}__${Disclosure.bemElements.contentsInner}`,
			contentsOuterClass = `${this.baseName}__${Disclosure.bemElements.contentsOuter}`,
			// options
			variant, animate,
			// elements
			children,
			// props that are used elsewhere
			/* eslint-disable @typescript-eslint/no-unused-vars */
			onCloseStart, onCloseCancel, onCloseEnd,
			onOpenStart, onOpenCancel, onOpenEnd,
			baseName, detailsRef, summary, summaryClass, updateOnResize, open: propsOpen,
			/* eslint-enable */
			// everything inherited by ReactAttributes & HTML
			...attributes
		} = this.props;
		const { height, lifecycle } = this.state;
		const classes = classNames(
			className,
			this.baseName,
			prefix(lifecycle),
			{
				[`${this.baseName}--panel`]: variant === 'panel',
				[prefix('reduced-motion')]: !animate,
			},
		);

		return (
			<BaseDetails
				ref={this.detailsRef}
				className={classes}
				// The open attribute should be applied on all states, except closing.
				// Otherwise, the animation won't work.
				open={this.isOpen}
				{...attributes}
			>
				{ this.Summary }
				<div
					style={(height !== undefined) ? { height } : undefined}
					className={contentsOuterClass}
					ref={(el): void => { this.contentsOuter = el; }}
					onTransitionEnd={this.onTransitionend}
				>
					<div className={contentsInnerClass}>
						{children}
					</div>
				</div>
			</BaseDetails>
		);
	}
}
