import React from 'react';
import classNames from 'classnames';
import debounce from 'lodash.debounce';
import BaseDetails, { BaseDetailsProps } from '../BaseDetails';
import BaseSummary from '../BaseSummary';
import Icon from '../Icon';
import { isElement, hasTransition } from '../../utilities/helpers';

export type DisclosureVariant = 'default' | 'panel';
export type DisclosureAnatomy = 'summary' | 'marker' | 'contentsInner' | 'contentsOuter';
export type DisclosureLifecycleState = 'open' | 'closed' | 'opening' | 'closing';
export type DisclosureLifecycleMethod = 'onCloseStart' | 'onCloseCancel' | 'onCloseEnd' | 'onOpenStart' | 'onOpenCancel' | 'onOpenEnd';
export interface DisclosureState {
	isOpen: boolean;
	lifecycle: DisclosureLifecycleState;
	height?: string;
}

export interface DisclosureProps extends BaseDetailsProps {
	/** The content for the summary element generated by the disclosure component. */
	summary: string;
	/** The base `className` according to BEM conventions. */
	baseName?: string;
	/** The `className` that will be applied to the `<summary>`. */
	summaryClass?: string;
	/** The `className` for the outer contents `<div>`. */
	contentsOuterClass?: string;
	/** The `className` that will be applied to the inner contents `<div>`. */
	contentsInnerClass?: string;
	/** A class that will be applied to the outer contents `<div>` while opening. */
	closingClass?: string;
	/** A class that will be applied to the outer contents `<div>` while closing. */
	openingClass?: string;
	/**
	 * The `className` that will be applied to the summary's icon indicator,
	 * which takes the place of the native `summary::marker` pseudo element.
	 */
	markerClass?: string;
	/** Whether resizing the window should trigger a height calculation update. */
	updateOnResize?: boolean;
	/** The variant for the disclosure. */
	variant?: DisclosureVariant;
	/** Whether to animate the opening/closing of the disclosure. */
	animate?: boolean;
	/** A reference to the inner <details> element. */
	detailsRef?: React.RefObject<HTMLDetailsElement>;
	/** Lifecycle method that is triggered when the disclosure begins to close. */
	onCloseStart?: () => void;
	/** Lifecycle method that is triggered when the user clicks on the disclosure as it's closing. */
	onCloseCancel?: () => void;
	/** Lifecycle method that is triggered when the disclosure has finished closing. */
	onCloseEnd?: () => void;
	/** Lifecycle method that is triggered when the disclosure begins to open. */
	onOpenStart?: () => void;
	/** Lifecycle method that is triggered when the user clicks on the disclosure as it's opening. */
	onOpenCancel?: () => void;
	/** Lifecycle method that is triggered when the disclosure has finished opening. */
	onOpenEnd?: () => void;
}

export default class Disclosure extends React.Component<DisclosureProps, DisclosureState> {
	/**
	 * The time in milliseconds to delay when recalculating the contents height
	 * due to a window resize. Only applies if `updateOnResize` is `true`.
	*/
	public static RESIZE_DEBOUNCE_DELAY = 150;
	public static bemBase = 'disclosure';
	public static bemElements: Record<DisclosureAnatomy, string> = {
		summary: 'summary',
		marker: 'marker',
		contentsInner: 'contents-inner',
		contentsOuter: 'contents-outer',
	}

	public detailsRef: React.RefObject<HTMLDetailsElement>;
	public contentsOuterHeight = 0;
	public contentsOuter: HTMLDivElement | null = null;
	private initialContentsOuterStyle?: string;

	public static defaultProps = {
		baseName: Disclosure.bemBase,
		animate: true,
		open: false,
		updateOnResize: true,
	}

	constructor(props: DisclosureProps) {
		super(props);
		this.state = {
			isOpen: props.open || Disclosure.defaultProps.open,
			lifecycle: props.open ? 'open' : 'closed',
		};
		this.detailsRef = props.detailsRef || React.createRef<HTMLDetailsElement>();
	}

	componentDidMount(): void {
		const { animate } = this.props;
		if (animate) {
			this.initialize();
		}
	}

	componentDidUpdate(prevProps: DisclosureProps): void {
		const {
			open: propsOpen,
			animate,
		} = this.props;
		const { isOpen: stateOpen } = this.state;
		if (propsOpen !== stateOpen && propsOpen !== prevProps.open) {
			switch (propsOpen) {
				case true:
					this.open('onOpenStart');
					break;
				case false:
					this.close('onCloseStart');
					break;
				default:
			}
		}
		if (animate !== prevProps.animate) {
			if (animate) {
				this.initialize();
			} else {
				this.reset();
			}
		}
	}

	private onWindowresize = debounce(() => {
		const { lifecycle } = this.state;
		this.removeHeight();
		this.contentsOuterHeight = this.findHeight;
		if (lifecycle === 'opening' || lifecycle === 'open') {
			this.setState({ height: `${this.contentsOuterHeight}px` });
		}
		if (lifecycle === 'closing' || lifecycle === 'closed') {
			this.setState({ height: '0' });
		}
	}, Disclosure.RESIZE_DEBOUNCE_DELAY)

	/**
	 * The `<summary>` click handler.
	 *
	 * As soon as a `<details>` element no longer has the `open` attribute,
	 * its inner contents disappear. To prevent this, we transition the height
	 * of the contents via its outer container, delaying the removal of the
	 * `open` attribute until the `transitionend` event triggers.
	 */
	private onSummaryClick = (e: React.MouseEvent<HTMLElement>): void => {
		e.preventDefault();
		const { isOpen, lifecycle } = this.state;
		const { animate } = this.props;
		if (!animate || !this.hasTransition) {
			this.setState({ isOpen: !isOpen });
		} else {
			switch (lifecycle) {
				case 'closed':
					this.open('onOpenStart');
					break;
				case 'closing':
					this.open('onCloseCancel');
					break;
				case 'open':
					this.close('onCloseStart');
					break;
				case 'opening':
					this.close('onOpenCancel');
					break;
				default:
			}
		}
	}

	private onToggle = (e: React.SyntheticEvent<HTMLDetailsElement>): void => {
		const { onToggle } = this.props;
		if (onToggle) {
			onToggle(e);
		}
	}

	// The transition begins with the summary click. On end, update the state if it's closed.
	private onTransitionend = (): void => {
		const { lifecycle } = this.state;
		if (lifecycle === 'opening') {
			this.setState({ lifecycle: 'open' }, () => {
				this.callLifecycleMethod('onOpenEnd');
			});
		} else if (lifecycle === 'closing') {
			this.setState({ lifecycle: 'closed', isOpen: false }, () => {
				this.callLifecycleMethod('onCloseEnd');
			});
		}
	}

	private get findHeight(): number {
		const { current: detailsRef } = this.detailsRef;
		const { isOpen } = this.state;
		const isClosed = !isOpen;
		if (detailsRef && this.contentsOuter) {
			if (isClosed) detailsRef.setAttribute('open', 'open');
			const { clientHeight } = this.contentsOuter;
			if (isClosed) detailsRef.removeAttribute('open');
			return clientHeight;
		}
		return 0;
	}

	private get hasTransition(): boolean {
		return hasTransition(this.contentsOuter);
	}

	private get Summary(): JSX.Element {
		const {
			baseName,
			summary,
			variant,
			summaryClass = `${baseName}__${Disclosure.bemElements.summary}`,
			markerClass = `${baseName}__${Disclosure.bemElements.marker}`,
		} = this.props;
		if (isElement(summary, 'summary')) return summary;
		const markerType = (variant === 'panel') ? 'chevron-down' : 'caret-right';
		const markerElement = <Icon variant={markerType} className={markerClass} />;
		const markerPosition = variant === 'panel' ? 'right' : 'left';
		return (
			<BaseSummary
				className={summaryClass}
				marker={markerElement}
				onClick={this.onSummaryClick}
				markerPosition={markerPosition}
			>
				{summary}
			</BaseSummary>
		);
	}

	private close(lifecycleMethod: DisclosureLifecycleMethod): void {
		this.setState({ height: '0' }, () => {
			this.setState({ lifecycle: 'closing' }, () => {
				this.callLifecycleMethod(lifecycleMethod);
			});
		});
	}

	private open(lifecycleMethod: DisclosureLifecycleMethod): void {
		this.setState({ height: `${this.contentsOuterHeight}px` }, () => {
			this.setState({ lifecycle: 'opening', isOpen: true }, () => {
				this.callLifecycleMethod(lifecycleMethod);
			});
		});
	}

	private initialize(): void {
		const { isOpen } = this.state;
		const { updateOnResize, animate } = this.props;
		if (animate) {
			this.contentsOuterHeight = this.findHeight;
			this.setState({ height: (isOpen) ? `${this.contentsOuterHeight}px` : '0' });
			if (updateOnResize) {
				window.addEventListener('resize', this.onWindowresize);
			}
		}
	}

	private reset(): void {
		const { updateOnResize } = this.props;
		this.removeHeight();
		if (updateOnResize) {
			window.removeEventListener('resize', this.onWindowresize);
		}
	}

	private removeHeight(): void {
		if (this.contentsOuter) {
			if (this.initialContentsOuterStyle) {
				this.setState({ height: `${this.initialContentsOuterStyle}px` });
			} else {
				this.setState({ height: undefined });
			}
		}
	}

	private callLifecycleMethod(name: DisclosureLifecycleMethod): void {
		const { [name]: method } = this.props;
		if (method) method();
	}

	render(): JSX.Element {
		const {
			// classes
			className, baseName,
			contentsInnerClass = `${baseName}__${Disclosure.bemElements.contentsInner}`,
			contentsOuterClass = `${baseName}__${Disclosure.bemElements.contentsOuter}`,
			// options
			variant, animate,
			// elements
			children,
			// props that are used elsewhere
			/* eslint-disable @typescript-eslint/no-unused-vars */
			onCloseStart, onCloseCancel, onCloseEnd,
			onToggle, onOpenStart, onOpenCancel, onOpenEnd,
			detailsRef, summary, summaryClass, updateOnResize, open: propsOpen,
			/* eslint-enable */
			// everything inherited by ReactAttributes & HTML
			...attributes
		} = this.props;
		const { isOpen, height, lifecycle } = this.state;
		const classes = classNames({
			[`${baseName}`]: true,
			[`${baseName}--panel`]: variant === 'panel',
			'reduced-motion': !animate,
			[`${lifecycle}`]: true,
		}, className);

		return (
			<BaseDetails
				ref={this.detailsRef}
				className={classes}
				open={isOpen}
				onToggle={this.onToggle}
				{...attributes}
			>
				{ this.Summary }
				<div
					style={{ height }}
					className={contentsOuterClass}
					ref={(el): void => { this.contentsOuter = el; }}
					onTransitionEnd={this.onTransitionend}
				>
					<div className={contentsInnerClass}>
						{children}
					</div>
				</div>
			</BaseDetails>
		);
	}
}
