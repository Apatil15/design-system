import React from 'react';
import ReactDOM from 'react-dom';
import {
	createPopper,
	Options,
	Instance,
	VirtualElement,
} from '@popperjs/core';
import { useForwardedRef } from '../../utilities/hooks';

export interface BasePopperProps extends React.HTMLAttributes<HTMLDivElement>, Partial<Options> {
	/** React ref for the reference node on which the popper element will be attached. */
	reference: React.RefObject<Element | VirtualElement>;
	/** Show/hide the arrow element. */
	arrow?: boolean;
	/** The className for the React portal. */
	portalClass?: string;
	/** The className for the arrow. */
	arrowClass?: string;
	/** The DOM element on which to mount the React portal generated by the BasePopper component. */
	mountPoint?: () => HTMLElement;
	/**
	 * Show/hide the popper element.
	 * This is the top-level API and will override the default show/hide behavior.
	 */
	isOpen?: boolean;
	/** Reference to attach to the popper node. */
	popperRef?: React.RefObject<HTMLDivElement>;
}

export interface BasePopperState {
	/** Show/hide the popper element. */
	isOpen: boolean;
}

class BasePopper extends React.Component<BasePopperProps, BasePopperState> {
	private PortalNode: HTMLDivElement;
	private popper: Instance | null;
	private popperRef: React.RefObject<HTMLDivElement>;
	private showEvents = ['mouseenter', 'focus'];
	private hideEvents = ['mouseleave', 'blur'];

	static defaultProps = {
		mountPoint: (): HTMLElement => document.body,
	}

	constructor(props: BasePopperProps) {
		super(props);
		this.PortalNode = this.createPortal();
		this.popperRef = props.popperRef || React.createRef<HTMLDivElement>();
		this.popper = null;
		this.state = {
			isOpen: props.isOpen || false,
		};
	}

	// append portal and create popper instance when component mounts
	componentDidMount(): void {
		const {
			mountPoint = BasePopper.defaultProps.mountPoint,
			reference,
			placement,
			modifiers,
			strategy,
			onFirstUpdate,
		} = this.props;

		const refEl = reference.current;
		const popperEl = this.popperRef.current;
		const mount = mountPoint();

		if (mount && !document.contains(this.PortalNode)) {
			mount.appendChild(this.PortalNode);
		}

		if (refEl && refEl instanceof Element) {
			this.showEvents.forEach((event) => {
				refEl.addEventListener(event, this.eventShow);
			});
			this.hideEvents.forEach((event) => {
				refEl.addEventListener(event, this.eventHide);
			});
		}

		if (popperEl && refEl) {
			this.popper = createPopper(
				refEl,
				popperEl,
				{
					modifiers,
					strategy,
					onFirstUpdate,
					placement,
				},
			);
		}
	}

	componentDidUpdate(prevProps: BasePopperProps): void {
		const {
			portalClass,
			isOpen,
			placement,
			modifiers,
			strategy,
			onFirstUpdate,
		} = this.props;

		// update the portal className
		if (portalClass !== undefined && prevProps.portalClass !== portalClass) {
			this.PortalNode.className = portalClass;
		}

		// update popper options
		if (this.popper) {
			const opts: Partial<Options> = {};

			if (prevProps.placement !== placement) {
				opts.placement = placement;
			}
			if (prevProps.modifiers !== modifiers) {
				opts.modifiers = modifiers;
			}
			if (prevProps.strategy !== strategy) {
				opts.strategy = strategy;
			}
			if (prevProps.onFirstUpdate !== onFirstUpdate) {
				opts.onFirstUpdate = onFirstUpdate;
			}

			if (Object.keys(opts).length) {
				this.popper.setOptions(opts);
				this.popper.update();
			}
		}

		// update isOpen state when props change
		if (prevProps.isOpen !== isOpen) {
			if (isOpen) {
				this.show();
			} else {
				this.hide();
			}
		}
	}

	componentWillUnmount(): void {
		const { reference } = this.props;
		const refEl = reference.current;

		this.PortalNode.remove();

		if (this.popper) {
			this.popper.destroy();
		}

		if (refEl && refEl instanceof Element) {
			this.showEvents.forEach((event) => {
				refEl.removeEventListener(event, this.eventShow);
			});
			this.hideEvents.forEach((event) => {
				refEl.removeEventListener(event, this.eventHide);
			});
		}
	}

	private get Popper(): React.ReactElement {
		const {
			children,
			arrow,
			arrowClass,
			/* eslint-disable @typescript-eslint/no-unused-vars */
			reference, portalClass, mountPoint, popperRef,
			isOpen: propOpen, placement, modifiers, strategy, onFirstUpdate,
			/* eslint-enable */
			...attributes
		} = this.props;
		const { isOpen } = this.state;

		return (
			<div
				ref={this.popperRef}
				data-show={isOpen || undefined}
				{...attributes}
			>
				{ children }
				{ arrow && <div className={arrowClass} data-popper-arrow /> }
			</div>
		);
	}

	// disable show/hide for events if open state is being set by prop
	private eventShow = (): void => {
		const { isOpen } = this.props;
		if (isOpen === undefined) {
			this.show();
		}
	}

	private eventHide = (): void => {
		const { isOpen } = this.props;
		if (isOpen === undefined) {
			this.hide();
		}
	}

	// show popper element; triggers 'data-show' attribute on popper element
	private show(): void {
		this.setState({ isOpen: true });
	}

	// hide tooltip; removes 'data-show' attribute on tooltip
	private hide(): void {
		this.setState({ isOpen: false });
	}

	// create react portal
	private createPortal(): HTMLDivElement {
		const { portalClass } = this.props;
		const node = document.createElement('div');
		if (portalClass) node.className = portalClass;
		return node;
	}

	render(): React.ReactElement {
		return ReactDOM.createPortal(this.Popper, this.PortalNode);
	}
}

type BasePopperRenderType = React.ForwardRefRenderFunction<HTMLDivElement, BasePopperProps>;
const BasePopperRender: BasePopperRenderType = (props, ref) => {
	const popperRef = useForwardedRef(ref);
	return <BasePopper popperRef={popperRef} {...props} />;
};

export default React.forwardRef<HTMLDivElement, BasePopperProps>(BasePopperRender);
